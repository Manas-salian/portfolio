---
interface Props {
  glitchColors?: string[];
  glitchSpeed?: number;
  centerVignette?: boolean;
  outerVignette?: boolean;
  smooth?: boolean;
  class?: string;
}

const {
  glitchColors,
  glitchSpeed = 2,
  centerVignette = false,
  outerVignette = false,
  smooth = true,
  class: className = "",
} = Astro.props;
---

<div
  class:list={[
    "letter-glitch relative overflow-hidden bg-background",
    className,
  ]}
  data-glitch-colors={glitchColors ? JSON.stringify(glitchColors) : undefined}
  data-glitch-speed={glitchSpeed}
  data-smooth={smooth}
>
  <canvas class="block h-full w-full"></canvas>
  {
    outerVignette && (
      <div class="pointer-events-none absolute top-0 left-0 h-full w-full bg-[radial-gradient(circle,_rgba(16,16,16,0)_60%,_rgba(16,16,16,1)_100%)]" />
    )
  }
  {
    centerVignette && (
      <div class="pointer-events-none absolute top-0 left-0 h-full w-full bg-[radial-gradient(circle,_rgba(0,0,0,0.8)_0%,_rgba(0,0,0,0)_60%)]" />
    )
  }
</div>

<script>
  class LetterGlitchEffect {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private glitchColors: string[];
    private glitchSpeed: number;
    private smooth: boolean;
    private animationId: number | null = null;
    private lastGlitchTime = Date.now();
    private letters: {
      char: string;
      color: string;
      targetColor: string;
      colorProgress: number;
    }[] = [];
    private grid = { columns: 0, rows: 0 };

    private readonly fontSize = 16;
    private readonly charWidth = 10;
    private readonly charHeight = 20;

    private readonly lettersAndSymbols = [
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "!",
      "@",
      "#",
      "$",
      "&",
      "*",
      "(",
      ")",
      "-",
      "_",
      "+",
      "=",
      "/",
      "[",
      "]",
      "{",
      "}",
      ";",
      ":",
      "<",
      ">",
      ",",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
    ];

    constructor(container: HTMLElement) {
      this.canvas = container.querySelector("canvas")!;
      this.ctx = this.canvas.getContext("2d")!;

      // Get theme colors from CSS variables if no custom colors provided
      const customColors = container.dataset.glitchColors;
      if (customColors) {
        this.glitchColors = JSON.parse(customColors);
      } else {
        // Use theme colors from CSS variables
        const style = getComputedStyle(document.documentElement);
        const accent = style.getPropertyValue("--accent").trim();
        const muted = style.getPropertyValue("--muted").trim();
        const border = style.getPropertyValue("--border").trim();

        // Create color variations based on theme
        this.glitchColors = [accent, muted, border];
      }

      this.glitchSpeed = Number(container.dataset.glitchSpeed) || 33;
      this.smooth = container.dataset.smooth !== "false";

      this.init();
    }

    private getRandomChar(): string {
      return this.lettersAndSymbols[
        Math.floor(Math.random() * this.lettersAndSymbols.length)
      ];
    }

    private getRandomColor(): string {
      return this.glitchColors[
        Math.floor(Math.random() * this.glitchColors.length)
      ];
    }

    private hexToRgb(hex: string): { r: number; g: number; b: number } | null {
      const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, (_m, r, g, b) => r + r + g + g + b + b);

      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result
        ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
          }
        : null;
    }

    private interpolateColor(
      start: { r: number; g: number; b: number },
      end: { r: number; g: number; b: number },
      factor: number
    ): string {
      const result = {
        r: Math.round(start.r + (end.r - start.r) * factor),
        g: Math.round(start.g + (end.g - start.g) * factor),
        b: Math.round(start.b + (end.b - start.b) * factor),
      };
      return `rgb(${result.r}, ${result.g}, ${result.b})`;
    }

    private calculateGrid(
      width: number,
      height: number
    ): { columns: number; rows: number } {
      const columns = Math.ceil(width / this.charWidth);
      const rows = Math.ceil(height / this.charHeight);
      return { columns, rows };
    }

    private initializeLetters(columns: number, rows: number): void {
      this.grid = { columns, rows };
      const totalLetters = columns * rows;
      this.letters = Array.from({ length: totalLetters }, () => ({
        char: this.getRandomChar(),
        color: this.getRandomColor(),
        targetColor: this.getRandomColor(),
        colorProgress: 1,
      }));
    }

    private resizeCanvas(): void {
      const parent = this.canvas.parentElement;
      if (!parent) return;

      const dpr = window.devicePixelRatio || 1;
      const rect = parent.getBoundingClientRect();

      this.canvas.width = rect.width * dpr;
      this.canvas.height = rect.height * dpr;

      this.canvas.style.width = `${rect.width}px`;
      this.canvas.style.height = `${rect.height}px`;

      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      const { columns, rows } = this.calculateGrid(rect.width, rect.height);
      this.initializeLetters(columns, rows);
      this.drawLetters();
    }

    private drawLetters(): void {
      if (this.letters.length === 0) return;

      const { width, height } = this.canvas.getBoundingClientRect();
      this.ctx.clearRect(0, 0, width, height);
      this.ctx.font = `${this.fontSize}px monospace`;
      this.ctx.textBaseline = "top";

      this.letters.forEach((letter, index) => {
        const x = (index % this.grid.columns) * this.charWidth;
        const y = Math.floor(index / this.grid.columns) * this.charHeight;
        this.ctx.fillStyle = letter.color;
        this.ctx.fillText(letter.char, x, y);
      });
    }

    private updateLetters(): void {
      if (this.letters.length === 0) return;

      const updateCount = Math.max(1, Math.floor(this.letters.length * 0.05));

      for (let i = 0; i < updateCount; i++) {
        const index = Math.floor(Math.random() * this.letters.length);
        if (!this.letters[index]) continue;

        this.letters[index].char = this.getRandomChar();
        this.letters[index].targetColor = this.getRandomColor();

        if (!this.smooth) {
          this.letters[index].color = this.letters[index].targetColor;
          this.letters[index].colorProgress = 1;
        } else {
          this.letters[index].colorProgress = 0;
        }
      }
    }

    private handleSmoothTransitions(): void {
      let needsRedraw = false;
      this.letters.forEach(letter => {
        if (letter.colorProgress < 1) {
          letter.colorProgress += 0.05;
          if (letter.colorProgress > 1) letter.colorProgress = 1;

          const startRgb = this.hexToRgb(letter.color);
          const endRgb = this.hexToRgb(letter.targetColor);
          if (startRgb && endRgb) {
            letter.color = this.interpolateColor(
              startRgb,
              endRgb,
              letter.colorProgress
            );
            needsRedraw = true;
          }
        }
      });

      if (needsRedraw) {
        this.drawLetters();
      }
    }

    private animate = (): void => {
      const now = Date.now();
      if (now - this.lastGlitchTime >= this.glitchSpeed) {
        this.updateLetters();
        this.drawLetters();
        this.lastGlitchTime = now;
      }

      if (this.smooth) {
        this.handleSmoothTransitions();
      }

      this.animationId = requestAnimationFrame(this.animate);
    };

    private init(): void {
      this.resizeCanvas();
      this.animate();

      let resizeTimeout: ReturnType<typeof setTimeout>;

      const handleResize = () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
          }
          this.resizeCanvas();
          this.animate();
        }, 100);
      };

      window.addEventListener("resize", handleResize);
    }

    public destroy(): void {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }

  // Initialize all letter glitch effects
  function initLetterGlitch() {
    document.querySelectorAll<HTMLElement>(".letter-glitch").forEach(el => {
      new LetterGlitchEffect(el);
    });
  }

  // Support both initial page load and Astro view transitions
  initLetterGlitch();
  document.addEventListener("astro:page-load", initLetterGlitch);
</script>
